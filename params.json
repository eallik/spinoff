{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Spinoff","tagline":"Spinoff is a framework for writing distributed, fault tolerant and scalable applications in Python. Spinoff is based on the Actor Model and borrows from Akka (location transparency, actor references, etc) and Erlang (processes, nodename@hosthost style node references (not implemented yet)).  ","body":"Overview\r\n========\r\n\r\nSpinoff is a framework for writing distributed, fault tolerant and scalable applications in Python.  Spinoff is based on the [Actor Model](http://en.wikipedia.org/wiki/Actor_model) and borrows from [Akka](http://akka.io) (location transparency, actor references, etc) and [Erlang](http://en.wikipedia.org/wiki/Erlang_(programming_language)) (processes, `nodename@hosthost` style node references (not implemented yet)).\r\n\r\nSpinoff has been built using [Twisted](http://twistedmatrix.com/) as the underlying framework and [ZeroMQ](http://www.zeromq.org/) (via `pyzmq` and a fork of `txzmq`) for remoting.\r\n\r\nSpinoff is currently under continuous development but is nevertheless usable for writing real applicationsâ€”its fault tolerance features also protect it against bugs in its own code.\r\n\r\n\r\nExample\r\n=======\r\n\r\nThe following is only a very small \"peek preview\" style example of what the framework can do. More examples and full documentation will follow soon.\r\n\r\n```python\r\n# spinoff/examples/example1.py\r\nfrom spinoff.actor import Actor\r\nfrom spinoff.actor.process import Process\r\nfrom spinoff.util.logging import dbg\r\nfrom spinoff.util.async import sleep, with_timeout\r\n\r\n\r\nclass ExampleProcess(Process):\r\n    def run(self):\r\n        child = self.spawn(ExampleActor)\r\n\r\n        while True:\r\n            dbg(\"sending greeting to %r\" % (child,))\r\n            child << ('hello!', self.ref)\r\n\r\n            dbg(\"waiting for ack from %r\" % (child,))\r\n            yield with_timeout(5.0, self.get('ack'))\r\n\r\n            dbg(\"got 'ack' from %r; now sleeping a bit...\" % (child,))\r\n            yield sleep(1.0)\r\n\r\n\r\nclass ExampleActor(Actor):\r\n    def pre_start(self):\r\n        dbg(\"starting\")\r\n\r\n    def receive(self, msg):\r\n        content, sender = msg\r\n        dbg(\"%r from %r\" % (content, sender))\r\n        sender << 'ack'\r\n\r\n    def post_stop(self):\r\n        dbg(\"stopping\")\r\n```\r\n\r\nThe example can be run using the following command:\r\n\r\n```bash\r\n$ twistd --nodaemon startnode --actor spinoff.examples.example1.ExampleProcess\r\n```\r\n\r\nor\r\n\r\n```bash\r\n$ twistd -n startnode -a spinoff.examples.example1.ExampleProcess\r\n```\r\n\r\nDistributed Example (with Remoting)\r\n===================================\r\n\r\n```python\r\n# spinoff/examples/example2.py\r\nfrom spinoff.actor import Actor\r\nfrom spinoff.actor.process import Process\r\nfrom spinoff.util.logging import dbg\r\nfrom spinoff.util.async import sleep, with_timeout\r\n\r\n\r\nclass ExampleProcess(Process):\r\n    def run(self, other_actor):\r\n        other_actor = lookup(other_actor) if isinstance(other_actor, str) else other_actor\r\n        while True:\r\n            dbg(\"sending greeting to %r\" % (other_actor,))\r\n            other_actor << ('hello!', self.ref)\r\n\r\n            dbg(\"waiting for ack from %r\" % (other_actor,))\r\n            yield with_timeout(5.0, self.get('ack'))\r\n\r\n            dbg(\"got 'ack' from %r; now sleeping a bit...\" % (other_actor,))\r\n            yield sleep(1.0)\r\n\r\n\r\nclass ExampleActor(Actor):\r\n    def pre_start(self):\r\n        dbg(\"starting\")\r\n\r\n    def receive(self, msg):\r\n        content, sender = msg\r\n        dbg(\"%r from %r\" % (content, sender))\r\n        sender << 'ack'\r\n\r\n    def post_stop(self):\r\n        dbg(\"stopping\")\r\n```\r\n\r\nThe example can be run using the following commands:\r\n\r\n```bash\r\n$ twistd --pidfile node1.pid --nodaemon startnode --remoting localhost:9700 --actor spinoff.examples.example2.ExampleActor --name other\r\n$ twistd --pidfile node2.pid --nodaemon startnode --remoting localhost:9701 --actor spinoff.examples.example2.ExampleProcess --params \"other_actor='localhost:9700/other'\"\r\n```\r\n\r\nor\r\n\r\n```bash\r\n$ twistd --pidfile node1.pid -n startnode -r :9700 -a spinoff.examples.example2.ExampleActor -n other\r\n$ twistd --pidfile node2.pid -n startnode -r :9701 -a spinoff.examples.example2.ExampleProcess -i \"other_actor='localhost:9700/other'\"\r\n```\r\n\r\nSame Distributed Code without Remoting\r\n======================================\r\n\r\nThe following example demonstrates how it's possible to run the same code, unmodified, in a single thread with no network/remoting involved whatsoever.  It's an illustration of how actors (components) written using Spinoff are xagnostic of how they are wired to work with other actors and can thus be viewed as abstract components containing only pure domain logic and no low level transportation and topology details.\r\n\r\n```python\r\n# spinoff/examples/example2_local.py\r\nfrom spinoff.actor.process import Process\r\nfrom spinoff.util.logging import dbg\r\n\r\nfrom .example2 import ExampleProcess, ExampleActor\r\n\r\n\r\nclass LocalApp(Process):\r\n    def run(self):\r\n        dbg(\"spawning ExampleActor\")\r\n        actor1 = self.spawn(ExampleActor)\r\n\r\n        dbg(\"spawning ExampleProcess\")\r\n        self.spawn(ExampleProcess.using(other_actor=actor1))\r\n\r\n        yield self.get()  # so that the entire app wouldn't exit immediately\r\n```\r\n\r\nThe example can be run using the following commands:\r\n\r\n```bash\r\n$ twistd --nodaemon startnode --actor spinoff.examples.example2_local.LocalApp\r\n```\r\n\r\nor\r\n\r\n```bash\r\n$ twistd -n startnode -a spinoff.examples.example2_local.LocalApp\r\n```\r\n\r\nOne might be tempted to ask, then, what is the difference between remoting frameworks such as CORBA and Spinoff.  The difference is that actors define clear boundaries where remoting could ever be used, as opposed to splitting a flow of tightly coupled logic into two nodes on the network, which, still providing valid output, can degrade in performance significantly.  This is not to say that actors with location transparency suffer none of such issues but the extent to which the problem exists is, arguably, an order of magnitude lower.\r\n"}